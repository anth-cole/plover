extern struct navigation_measurement_t (
  pseudorange :: double
);
extern GPS_OMEGAE_DOT :: double;
extern GPS_C :: double;

extern sqrt (x :: double) :: double;

static rot_small (x :: double) :: double[3,3]
 := vec(vec(1.0, x, 0.0),
        vec(-x, 1.0, 0.0),
        vec(0.0, 0.0, 1.0));

static norm {n :: u32} (v :: double[n]) :: double
--  := sqrt (sum i in n -> (v[i] * v[i]));
  := sqrt (s := 0.0; for i in n -> (s <- s + v[i] * v[i]); s);
static normalize {n :: u32} (v :: double[n]) :: double[n]
  := v / norm v; -- Should be a test of loop invariant code motion

pvt {n_used :: u8}
    (sat_pos :: double[n_used,3])
    (nav_meas :: navigation_measurement_t[n_used])
    (rx_state :: double[3])
    (out correction :: double[3+1])
    (out G :: double[n_used,3+1])
    (out X :: double[3+1, n_used])
    :: Void

  := (
    los := vec j in 0:n_used -> (
             tau := norm (rx_state - sat_pos[j]) / GPS_C;
             xk_new := rot_small (GPS_OMEGAE_DOT * tau) * sat_pos[j];
             xk_new - rx_state;
           );
    G <- vec j in 0:n_used -> normalize (-los[j] # vec(1));
    omp := vec i in 0:n_used -> nav_meas[i].pseudorange - norm los[i];
    X <- (G^T * G)^(-1) * G^T;
    correction <- X * omp;
  );

extern MAX_OBS_DIM :: u32;
extern MAX_STATE_DIM :: u32;

extern struct nkf_t (
  state_dim :: u32;
  obs_dim :: u32;
  amb_drift_var :: double;
  decor_mtx :: double[MAX_OBS_DIM * MAX_OBS_DIM];
  decor_obs_mtx :: double[MAX_STATE_DIM * MAX_OBS_DIM] as double[obs_dim, state_dim];
  decor_obs_cov :: double[MAX_OBS_DIM];
  null_basis_Q :: double[(MAX_STATE_DIM - 3) * MAX_OBS_DIM];
  state_mean :: double[MAX_STATE_DIM] as double[state_dim];
  state_cov_U :: double[MAX_STATE_DIM * MAX_STATE_DIM] as UpperUnitTriangular double[state_dim, _];
  state_cov_D :: double[MAX_STATE_DIM] as Diagonal double[state_dim, _];
  l_sos_avg :: double;

  assert (state_dim < MAX_STATE_DIM);
  assert (ob_dim < MAX_OBS_DIM);
);

--const 0 :: double@ConstantMatrix[n,m];

-- @Block (double[2,2],double[2,m-3]; , const 0) double[n,m]

static get_sos_innov (kf :: *nkf_t) (decor_obs :: double[kf.obs_dim]) :: double
  := ( assert (kf != NULL);
       assert (decor_obs != NULL);

       if kf.state_dim == 0 or kf.obs_dim == 0
         then return 0;

       predicted_obs := kf.decor_obs_mtx * kf.state_mean;
       hu := kf.decor_obs_mtx * kf.state_cov_U   :: double[kf.obs_dim, kf.state_dim];
       t := diag (hu * kf.state_cov_D * hu^T);
       y := predicted_obs - decor_obs;
       sos := y^T * Diagonal (1 / t) * y as double;
       return sos;
     );
