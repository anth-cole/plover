import prelude;
import qr;
__C__ "#include <libswiftnav/linear_algebra.h>";

extern (
  -- not currently used
  matrix_inverse (n :: u32) (in m :: double[n,n]) (out minv :: double[n,n]) :: u32;
);

test {n}
     (out m :: double[n,n])
     (inout x :: double[n])
     :: double := (
  m <- vec i in n,
           j in n ->
        rand_uniform () * i;
  y := m * x;
  x <- y;
  return norm y;
);

-- currently needed for plover compiler
main () :: int := 0;

-- maintain a map from row to sid
-- given sid, return corresponding row, and update map for remaining rows
drop_row {num_sats}
  (sid :: int)
  (sid_map :: int[num_sats])
  (out new_map :: int[num_sats-1])
  :: int := (

  row :: int;

  for i in num_sats -> (
    if sid_map[i] == sid then (
      row <- i;
    );
  );

  new_map[0:row] <- sid_map[0:row];
  new_map[row:]  <- sid_map[row+1:];

  return row;
);

kalman_predict_ {dim}
  (x :: double[dim])
  (P :: double[dim, dim])
  (F :: double[dim, dim])
  (Q :: double[dim, dim])
  (out x_new :: double[dim])
  (out P_new :: double[dim, dim])
  :: () := (

  P_new <- F * P * F^T + Q;
  x_new <- F * x;
);

kalman_update_ {xdim, dim}
  (x :: double[xdim])
  (P :: double[xdim, xdim])
  (y :: double[dim])
  (H :: double[dim, xdim])
  (R :: double[dim, dim])
  (out x_new :: double[xdim])
  (out P_new :: double[xdim, xdim])
  :: () := (

  id :: Scalar double[xdim, xdim];
  id <- 1;
  innovation := y - H * x;
  pht := P * H^T;
  S := H * pht + R;

  -- instead of computing
  --    K <- P * H^T * S^(-1) :: double[xdim, dim];
  --    K * innovation, K * H
  -- we use the least squares procedure to compute
  --    S^(-1) * [innovation | H]
  -- then multiply the other factors

  block := (innovation^T # H^T)^T;
  block_out :: double[dim, xdim+1];
  resid :: double[xdim+1];
  qr_solve (inout S) (inout block) (out block_out) (out resid);
  x_new <- x + pht * block_out[:, 0];
  P_new <- (id - pht * block_out[:, 1:]) * P;

  ()
);

print_all_ {dim}
  (innovation :: double[dim])
  (S :: double[dim, dim])
  (Si :: double[dim, dim])
  (K :: double[dim, dim])
  (x_new :: double[dim])
  (P_new :: double[dim, dim])
  :: () := (
  print_vec innovation;
  print_mat S;
  print_mat Si;
  print_mat K;
  print_vec x_new;
  print_mat P_new;
);
