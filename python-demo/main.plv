import prelude;
import qr;
__C__ "#include <libswiftnav/linear_algebra.h>";

extern (
  -- not currently used
  matrix_inverse (n :: u32) (in m :: double[n,n]) (out minv :: double[n,n]) :: u32;
);

-- currently needed for plover compiler
main () :: int := 0;

kalman_predict_ {dim}
  (x :: double[dim])
  (P :: double[dim, dim])
  (F :: double[dim, dim])
  (Q :: double[dim, dim])
  (out x_new :: double[dim])
  (out P_new :: double[dim, dim])
  :: () := (

  P_new <- F * P * F^T + Q;
  x_new <- F * x;
);

kalman_update_ {xdim, dim}
  (x :: double[xdim])
  (P :: double[xdim, xdim])
  (y :: double[dim])
  (H :: double[dim, xdim])
  (R :: double[dim, dim])
  (out x_new :: double[xdim])
  (out P_new :: double[xdim, xdim])
  :: () := (

  id :: Scalar double[xdim, xdim];
  id <- 1;
  innovation := y - H * x;
  pht := P * H^T;
  S := H * pht + R;

  -- instead of computing
  --    K <- P * H^T * S^(-1) :: double[xdim, dim];
  --    K * innovation, K * H
  -- we use the least squares procedure to compute
  --    S^(-1) * [innovation | H]
  -- then multiply the other factors

  block := (innovation^T # H^T)^T;
  block_out :: double[dim, xdim+1];
  resid :: double[xdim+1];
  qr_solve (inout S) (inout block) (out block_out) (out resid);
  x_new <- x + pht * block_out[:, 0];
  P_new <- (id - pht * block_out[:, 1:]) * P;

  ()
);
